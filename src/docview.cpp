/*
    Copyright (C) 2020 Akib Azmain
    
    This file is part of Docview.
    
    Docview is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    Docview is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with Docview. If not, see <http://www.gnu.org/licenses/>.
*/

#include <gtkmm/application.h>
#include <gtkmm/builder.h>
#include <gtkmm/window.h>
#include <gtkmm/aboutdialog.h>
#include <gtkmm/dialog.h>
#include <gtkmm/button.h>
#include <gtkmm/widget.h>
#include <gtkmm/modelbutton.h>
#include <gtkmm/togglebutton.h>
#include <gtkmm/treestore.h>
#include <gtkmm/treeview.h>
#include <gtkmm/box.h>
#include <gtkmm/paned.h>
#include <gtkmm/label.h>
#include <gtkmm/stack.h>
#include <gtkmm/stackswitcher.h>
#include <webkit2/webkit2.h>
#include <glibmm/ustring.h>
#include <glibmm/object.h>
#include <memory>
#include <exception>
#include <iostream>
#include <functional>
#include <array>
#include <utility>
#include <vector>

// This global variable will contain pointer to Gtk::Builder (managed by Glib::RefPtr)
Gtk::Builder* builder = nullptr;

/**
 * @brief Returns shared pointer to widget specified by given id
 * 
 * @tparam widget_type type of widget
 * @param id id of widget
 * @return shared pointer to widget
 */
template <class widget_type = Gtk::Widget>
std::shared_ptr<widget_type> get_widget(std::string id)
{
    widget_type* widget_ptr;
    builder->get_widget(id, widget_ptr);
    std::shared_ptr<widget_type> widget;
    widget.reset(widget_ptr);
    return widget;
}

int main(int argc, char** argv)
{

    // Create new Gtk::Application object
	auto app = Gtk::Application::create(argc, argv, "org.docview");

    // Create new Gtk::Builder object
    auto builder = Gtk::Builder::create();

    // Set the global builder variable to enable the use of function get_widget
    ::builder = builder.get();
    
    // Register WebKit's WebView and Settings widget to prevent builder errors
    webkit_web_view_new();
    webkit_settings_new();

    // Builder the UI from .ui file generated by glade
    try
    {
        builder->add_from_file("src/window.ui");
    }

    // On any exception, print a error message and exit
    catch (Glib::Error& exception)
    {
        std::cerr << "Exception occurred: what(): " << exception.what() << std::endl;
        std::terminate();
    }

    // Get pointer to widget from builder
    auto window = get_widget<Gtk::Window>("window_main");
    auto doc_contents = get_widget<Gtk::Box>("doc_contents");
    auto contents = get_widget<Gtk::Paned>("contents");
    auto sidebar_toggle_button = get_widget<Gtk::ToggleButton>("sidebar_toggle_button");
    auto about_button = get_widget<Gtk::ModelButton>("about_button");
    auto about_dialog = get_widget<Gtk::AboutDialog>("about_dialog");
    auto preferences_button = get_widget<Gtk::ModelButton>("preferences_button");
    auto preferences_dialog = get_widget<Gtk::Dialog>("preferences_dialog");
    auto quit_button = get_widget<Gtk::Button>("quit_button");
    auto sidebar_tree = get_widget<Gtk::TreeView>("sidebar_tree");
    auto tab_switcher = get_widget<Gtk::StackSwitcher>("tabs");
    auto stack = get_widget<Gtk::Stack>("doc_webviews");
    auto history_previous_button = get_widget<Gtk::Button>("history_previous");
    auto history_next_button = get_widget<Gtk::Button>("history_next");
    auto new_tab_button = get_widget<Gtk::Button>("new_tab_button");
    auto close_tab_button = get_widget<Gtk::ModelButton>("close_tab_button");
    auto title = get_widget<Gtk::Stack>("title");
    auto title_label = get_widget<Gtk::Label>("title_label");
    GObject* webview_settings = gtk_builder_get_object(builder->gobj(), "webview_settings");

    // This structure contains the contents of sidebar
    Glib::RefPtr<Gtk::TreeStore> sidebar_contents;

    // The only column of sidebar tree
    Gtk::TreeModelColumn<Glib::ustring> sidebar_data;

    // This mapped array holds all tabs
    std::vector<Gtk::Widget*> tabs;

    // Lambda function to call on sidebar toggle button clicked
    std::function<void()> on_sidebar_toggle_button_clicked = [&]() -> void
    {

        // Used to store sidebar size
        static int sidebar_size;

        // If sidebar enabled, restore previous size
        if (sidebar_toggle_button->get_active())
        {
            contents->set_position(sidebar_size);
        }

        // If sidebar disabled, save sidebar size, set it's size to 0
        else
        {
            sidebar_size = contents->get_position();
            contents->set_position(0);
        }
    };

    // Lambda function to call on sidebar resized
    std::function<void()> on_sidebar_resized = [&]() -> void
    {

        // If user tries resize sidebar to less than 200 pixels, set the size to 200 pixel
        if (contents->get_position() < 200 && sidebar_toggle_button->get_active())
        {
            contents->set_position(200);
        }

        // If user tries to change the size of sidebar when it's hidden, set the size to 0 pixel
        else if (!sidebar_toggle_button->get_active())
        {
            contents->set_position(0);
        }
    };

    // Lambda function to call on about button clicked
    std::function<void()> on_about_button_clicked = [&]() -> void
    {

        // User wants to see the about dialog, present that
        about_dialog->present();
    };

    // Lambda function to call on preferences button clicked
    std::function<void()> on_preferences_button_clicked = [&]() -> void
    {

        // User want the preferences dialog dialog, present that
        preferences_dialog->present();
    };

    // Lambda function to call on sidebar option selected
    std::function<void(const Gtk::TreeModel::Path&, Gtk::TreeView::Column*)> on_sidebar_option_selected =
        [&](const Gtk::TreeModel::Path& path, Gtk::TreeView::Column*) -> void
    {

        // Iterator to the row
        Gtk::TreeModel::iterator it = sidebar_contents->get_iter(path);

        // Make sure the iterator is valid
        if (path)
        {

            // Dereference the iterator
            Gtk::TreeModel::Row row = *it;

            // Just a dummy, //TODO: remove
            WebKitWebView* webview = WEBKIT_WEB_VIEW(stack->get_visible_child()->gobj());
            webkit_web_view_load_html(webview, Glib::ustring(
                "<html>"
                "<head>"
                "<title>"
                + row[sidebar_data] +
                "</title>"
                "</head>"
                "<body>"
                "<p>"
                "You clicked: " + row[sidebar_data] + "!"
                "</p>"
                "</body>"
                "</html>").c_str(),
            nullptr);
        }
    };

    // Lambda function to call on webview load change
    void(*on_webview_load_change)(WebKitWebView*, WebKitLoadEvent, void*) =
        [](WebKitWebView* webview, WebKitLoadEvent event, void*) -> void
    {
        auto title = ((Gtk::Stack*)Glib::wrap(GTK_WIDGET(webview))->get_parent())->child_property_title(
            *Glib::wrap(GTK_WIDGET(webview))
        );

        const char* webview_title = webkit_web_view_get_title(webview);

        // If the page has finished loading, change the title of window to title of page
        if (event == WEBKIT_LOAD_FINISHED)
        {
            if (webview_title)
                title = webview_title + Glib::ustring(" - Docview");
            else
                title = "Docview";
        }

        // Page is being loaded, show loading in title
        else
        {
            title = "Loading - Docview";
        }
    };

    // Lambda function to call on title changed
    std::function<void()> on_title_changed = [&]()
    {
        title_label->set_label(stack->child_property_title(*stack->get_visible_child()));
    };

    // Lambda function to call on active tab change
    std::function<void()> on_active_tab_changed = [&]()
    {
        on_title_changed();
    };

    // Lambda function to call on tab added
    std::function<void()> on_tab_added = [&]()
    {

        // Tab number, automatically initialized with zero
        static unsigned int tab_num;

        // Increment tab_num, as 0 is already used by initial tab
        tab_num++;

        // Create and configure new webview
        Gtk::Widget* webview = Glib::wrap(webkit_web_view_new());
        webkit_web_view_set_settings(
            WEBKIT_WEB_VIEW(webview->gobj()),
            WEBKIT_SETTINGS(webview_settings)
        );
        g_signal_connect(webview->gobj(), "load-changed",
            G_CALLBACK(on_webview_load_change), nullptr);

        // Create new tab, present it to user
        stack->add(*webview, std::to_string(tab_num), "Empty Page - Docview");
        webview->show();
        stack->set_visible_child(*webview);

        // Show tab_switcher in title and show changes
        if (tabs.size() >= 1)
            title->set_visible_child(*tab_switcher);
        window->show_all_children();

        // Configure event handler
        stack->child_property_title(*webview).signal_changed().connect(sigc::mem_fun(
            on_title_changed, &std::function<void()>::operator()
        ));

        // Insert the tab to tabs
        tabs.push_back(webview);
    };

    // Lambda function to call on tab closed
    std::function<void()> on_tab_closed = [&]()
    {

        // If there will be no tabs left after removal, close the window
        if (tabs.size() - 1 == 0)
        {
            window->hide();
            return;
        }

        // The new stack
        std::shared_ptr<Gtk::Stack> new_stack = std::make_shared<Gtk::Stack>();

        // The tab to close
        Gtk::Widget* tab_to_close = stack->get_visible_child();

        // Move all widgets to the new stack
        for (unsigned long i = 0; i < tabs.size(); i++)
        {

            // If the current tab is the tab to close, don't add it and remove it from tabs
            if (tabs[i] == tab_to_close)
            {
                tabs.erase(tabs.begin() + i--);
            }
            else
            {

                // Copy the title before reparenting, as trying to acesss it after it will cause errors
                auto title = stack->child_property_title(*tabs[i]).get_value();

                // Move the tabs and title
                tabs[i]->reparent(*new_stack);
                tabs[i]->show();
                new_stack->child_property_title(*tabs[i]) = title;

                // Give a unique dummy name
                new_stack->child_property_name(*tabs[i]) = std::to_string(i);

                // Configure event handler
                stack->child_property_title(*tabs[i]).signal_changed().connect(sigc::mem_fun(
                    on_title_changed, &std::function<void()>::operator()
                ));
            }
        }

        // Copy properties from previous to new stack
        new_stack->set_transition_duration(stack->get_transition_duration());
        new_stack->set_transition_type(stack->get_transition_type());
        new_stack->set_homogeneous(stack->get_homogeneous());
        new_stack->set_hhomogeneous(stack->get_hhomogeneous());
        new_stack->set_vhomogeneous(stack->get_vhomogeneous());
        new_stack->set_interpolate_size(stack->get_interpolate_size());

        // If only one tab is left, show only tab title in title
        if (tabs.size() == 1)
        {
            title->set_visible_child(*title_label);
        }

        // Swap previous and new stack
        std::swap(stack, new_stack);

        // Update the tab switcher and window
        doc_contents->pack_start(*stack);
        tab_switcher->set_stack(*stack);
        window->show_all_children();

        // Configure signal handler
        stack->property_visible_child().signal_changed().connect(sigc::mem_fun(on_active_tab_changed,
            &std::function<void()>::operator()
        ));

        // Call the signal handler to handle active tab change, as active tab is changed
        on_active_tab_changed();
    };

    // Lambda function to call on history previous button clicked
    std::function<void()> on_history_previous = [&]()
    {
        Gtk::Widget* webview = stack->get_visible_child();
        if (webkit_web_view_can_go_back(WEBKIT_WEB_VIEW(webview->gobj())))
            webkit_web_view_go_back(WEBKIT_WEB_VIEW(webview->gobj()));
    };

    // Lambda function to call on history next button clicked
    std::function<void()> on_history_next = [&]()
    {
        Gtk::Widget* webview = stack->get_visible_child();
        if (webkit_web_view_can_go_forward(WEBKIT_WEB_VIEW(webview->gobj())))
            webkit_web_view_go_forward(WEBKIT_WEB_VIEW(webview->gobj()));
    };

    // Lambda function to call on quit button clicked
    std::function<void()> on_quit_button_clicked = [&]()
    {
        window->hide();
    };

    // Configure widgets to call the above handlers in appropiate events
    sidebar_toggle_button->signal_clicked().connect(
        sigc::mem_fun(on_sidebar_toggle_button_clicked, &std::function<void()>::operator())
    );
    about_button->signal_clicked().connect(
        sigc::mem_fun(on_about_button_clicked, &std::function<void()>::operator())
    );
    preferences_button->signal_clicked().connect(
        sigc::mem_fun(on_preferences_button_clicked, &std::function<void()>::operator())
    );
    contents->property_position().signal_changed().connect(
        sigc::mem_fun(on_sidebar_resized, &std::function<void()>::operator())
    );
    sidebar_tree->signal_row_activated().connect(sigc::mem_fun(on_sidebar_option_selected,
        &std::function<void(const Gtk::TreeModel::Path&, Gtk::TreeView::Column*)>::operator()
    ));
    new_tab_button->signal_clicked().connect(sigc::mem_fun(on_tab_added,
        &std::function<void()>::operator()
    ));
    close_tab_button->signal_clicked().connect(sigc::mem_fun(on_tab_closed,
        &std::function<void()>::operator()
    ));
    stack->property_visible_child().signal_changed().connect(sigc::mem_fun(on_active_tab_changed,
        &std::function<void()>::operator()
    ));
    history_previous_button->signal_clicked().connect(sigc::mem_fun(on_history_previous,
        &std::function<void()>::operator()
    ));
    history_next_button->signal_clicked().connect(sigc::mem_fun(on_history_next,
        &std::function<void()>::operator()
    ));
    quit_button->signal_clicked().connect(sigc::mem_fun(on_quit_button_clicked,
        &std::function<void()>::operator()
    ));

    // Manually trigger tab added handler, which will create the initial tab
    on_tab_added();

    {
        Gtk::TreeModel::ColumnRecord sidebar_columns;
        sidebar_columns.add(sidebar_data);
        sidebar_contents = Gtk::TreeStore::create(sidebar_columns);
        sidebar_tree->set_model(sidebar_contents);
        sidebar_tree->append_column("", sidebar_data);

        // Put some dummy data in sidebar, //TODO: remove
        Gtk::TreeModel::Row row = *(sidebar_contents->append());
        row[sidebar_data] = "A";
        row = *(sidebar_contents->append());
        row[sidebar_data] = "B";
        Gtk::TreeModel::Row child_row = *(sidebar_contents->append(row.children()));
        child_row[sidebar_data] = "C";
        Gtk::TreeModel::Row grandchild_row = *(sidebar_contents->append(child_row.children()));
        grandchild_row[sidebar_data] = "D";
        child_row = *(sidebar_contents->append(row.children()));
        child_row[sidebar_data] = "E";
    }

    // Just a dummy, //TODO: remove
    {
        webkit_web_view_load_html(WEBKIT_WEB_VIEW(tabs[0]->gobj()),
            "<html>"
            "<head>"
            "<title>Empty Page</title>"
            "</head>"
            "<body>"
            "<p>"
            "Welcome to Docview!"
            "</p>"
            "</body>"
            "</html>",
        nullptr);
    }

    // Finally, show the window to user
    doc_contents->show_all_children();
	return app->run(*window);
}
